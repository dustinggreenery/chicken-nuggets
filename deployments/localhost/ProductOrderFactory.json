{
  "address": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vendorAddress",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "PONo",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "timeToAccept",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "timeToShip",
          "type": "uint256"
        }
      ],
      "name": "createProductOrder",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0x2ee7a7b0a5fcfad5b0f4207a52d2bfef443e0afc2377107295ee3a03f4e4d356",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    "transactionIndex": 0,
    "gasUsed": "134947",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x376d5fcf3cd5fc0a7eeca1bdfbc12358dcf5c464f0d6f4d58dd5cba239e6be32",
    "transactionHash": "0x2ee7a7b0a5fcfad5b0f4207a52d2bfef443e0afc2377107295ee3a03f4e4d356",
    "logs": [],
    "blockNumber": 1,
    "cumulativeGasUsed": "134947",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "7c3d957a6a3ff7fe526dd8a04ea980aa",
  "metadata": "{\"compiler\":{\"version\":\"0.8.8+commit.dddeac2f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vendorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"PONo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeToAccept\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeToShip\",\"type\":\"uint256\"}],\"name\":\"createProductOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ProductOrderFactory.sol\":\"ProductOrderFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AutomationCompatibleInterface {\\n  /**\\n   * @notice method that is simulated by the keepers to see if any work actually\\n   * needs to be performed. This method does does not actually need to be\\n   * executable, and since it is only ever simulated it can consume lots of gas.\\n   * @dev To ensure that it is never called, you may want to add the\\n   * cannotExecute modifier from KeeperBase to your implementation of this\\n   * method.\\n   * @param checkData specified in the upkeep registration so it is always the\\n   * same for a registered upkeep. This can easily be broken down into specific\\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n   * same contract and easily differentiated by the contract.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with, if\\n   * upkeep is needed. If you would like to encode data to decode later, try\\n   * `abi.encode`.\\n   */\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n  /**\\n   * @notice method that is actually executed by the keepers, via the registry.\\n   * The data returned by the checkUpkeep simulation will be passed into\\n   * this method to actually be executed.\\n   * @dev The input to this method should not be trusted, and the caller of the\\n   * method should not even be restricted to any single registry. Anyone should\\n   * be able call it, and the input should be validated, there is no guarantee\\n   * that the data passed in is the performData returned from checkUpkeep. This\\n   * could happen due to malicious keepers, racing keepers, or simply a state\\n   * change while the performUpkeep transaction is waiting for confirmation.\\n   * Always validate the data passed in.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation. If it is encoded, it can easily be decoded into other types by\\n   * calling `abi.decode`. This data should not be trusted, and should be\\n   * validated against the contract's current state.\\n   */\\n  function performUpkeep(bytes calldata performData) external;\\n}\\n\",\"keccak256\":\"0x67076747c6f66d8d43472a56e72879c350056bff82e069addaf9064922863340\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n * @notice This is a deprecated interface. Please use AutomationCompatibleInterface directly.\\n */\\npragma solidity ^0.8.0;\\nimport {AutomationCompatibleInterface as KeeperCompatibleInterface} from \\\"./AutomationCompatibleInterface.sol\\\";\\n\",\"keccak256\":\"0xac76a31c20c6d66196247376d113a0f19229569ab8c123989649d50be3333e0a\",\"license\":\"MIT\"},\"contracts/ProductOrder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\\\";\\r\\n\\r\\nerror ProductOrder__NotFactory();\\r\\nerror ProductOrder__NotPurchaser();\\r\\nerror ProductOrder__NotVendor();\\r\\n\\r\\n\\r\\ncontract ProductOrder is KeeperCompatibleInterface {\\r\\n    // State of Order\\r\\n    enum POState {\\r\\n\\t    SENT,\\r\\n\\t    CANCELLED,\\r\\n\\t    ACCEPTED,\\r\\n\\t    DISPUTE,\\r\\n        END,\\r\\n        DISPUTE_END\\r\\n    }\\r\\n    POState private s_state;\\r\\n    \\r\\n    // All addresses\\r\\n    address private i_factoryAddress;\\r\\n    address private i_purchaserAddress;\\r\\n    address private i_vendorAddress;\\r\\n\\r\\n    // Amount of Money currently in contract\\r\\n    uint256 private s_amountOfMoney;\\r\\n\\r\\n    // Identifier to know what purchase order it is.\\r\\n    uint256 private i_PONo;\\r\\n\\r\\n    // Timing to accept and shipping\\r\\n    uint256 private i_timeToAccept;\\r\\n    uint256 private i_acceptTimeStamp;\\r\\n    uint256 private i_timeToShip;\\r\\n    uint256 private s_shippingTimeStamp;\\r\\n\\r\\n    // Dispute Variables\\r\\n    int256 private s_tokenWorthGot = -1;\\r\\n    uint256 private s_tokenWorthShipped;\\r\\n\\r\\n    // Events??\\r\\n\\r\\n    // Modifiers\\r\\n    modifier onlyFactory() {\\r\\n        // Continue if sender is the factory.\\r\\n        _;\\r\\n    }\\r\\n    modifier onlyPurchaser() {\\r\\n        // Continue if sender is the purchaser.\\r\\n        _;\\r\\n    }\\r\\n    modifier onlyVendor() {\\r\\n        // Continue if sender is the vendor.\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    constructor(address purchaserAddress, address vendorAddress, uint256 PONo, uint256 timeToAccept, uint256 acceptTimeStamp, uint256 timeToShip) {\\r\\n        // Sets i_factoryAddress to msg.sender.\\r\\n        // Sets above parameters to their respective variables in the smart contract.\\r\\n        // Sets s_state to state SENT.\\r\\n    }\\r\\n\\r\\n    function setPayment() public payable onlyFactory {\\r\\n        // Sets s_amountOfMoney to msg.value.\\r\\n    }\\r\\n\\r\\n    function cancelOrder() public payable onlyPurchaser {\\r\\n        // Requires s_state to be in SENT\\r\\n        // Refund s_amountOfMoney to purchaserAddress.\\r\\n        // Sets s_amountOfMoney to 0.\\r\\n        // Sets s_state to CANCELLED\\r\\n    }\\r\\n\\r\\n    function recievePurchaseOrder(bool orderAccepted, uint256 amountOfPOAccepted) public onlyVendor {\\r\\n        // Requires s_state to be SENT\\r\\n        // Requires amountOfPOAccepted to be less than s_amountOfMoney\\r\\n        // If orderAccepted is false\\r\\n        //     s_state is set to CANCELLED\\r\\n        //     Refunds s_amountOfMoney to purchaserAddress\\r\\n        //     Sets s_amountOfMoney to 0\\r\\n        // Else if orderAccepted is true\\r\\n        //     s_state is set to ACCEPTED.\\r\\n        //     Sets s_shippingTimeStamp to block.timestamp.\\r\\n        //     Refunds (s_amountOfMoney - amountOfPOAccepted) to purchaserAddress.\\r\\n        //     Sets s_amountOfMoney to amountOfPOAccepted\\r\\n    }\\r\\n\\r\\n    function setShipmentValue(uint256 shipmentValue) public payable onlyPurchaser {\\r\\n        // Requires s_state to be ACCEPTED\\r\\n        // Requires shipmentValue to be less than or equal to s_amountOfMoney and greater than 0.\\r\\n        // If shipmentValue is equal to s_amountOfMoney:\\r\\n        //     Send s_amountOfMoney to vendorAddress.\\r\\n        //     Sets s_amountOfMoney to 0.\\r\\n        //     s_state is set to END\\r\\n        // Else if shipment value isn\\u2019t equal to s_amountOfMoney:\\r\\n        //     s_state is set to DISPUTE.\\r\\n        //     s_tokenWorthGot is set to shipmentValue\\r\\n    }\\r\\n\\r\\n    function setPurchaserDispute(uint256 tokenWorthGot) public onlyPurchaser {\\r\\n        // Sets s_tokenWorthGot to tokenWorthGot.\\r\\n    }\\r\\n\\r\\n    function setVendorDispute(uint256 tokenWorthShipped) public onlyVendor {\\r\\n        // Sets s_tokenWorthShipped to tokenWorthShipped.\\r\\n    }\\r\\n\\r\\n    function checkUpkeep(bytes memory) public override returns (bool upkeepNeeded, bytes memory) {\\r\\n        // If s_state is SENT\\r\\n        //     upkeepNeeded equals if (block.timestamp - i_acceptTimeStamp) is greater than i_timeToAccept.\\r\\n        // If s_state is ACCEPTED\\r\\n        //     upkeepNeeded both conditions (AND)\\r\\n        //         (block.timestamp - s_shippingTimeStamp) is greater than i_timeToShip\\r\\n        //         s_tokenWorthGot equals -1\\r\\n        // If s_state is DISPUTE\\r\\n        //     upkeepNeeded equals if s_tokenWorthGot and s_tokenWorthShipped are equal.\\r\\n    }\\r\\n\\r\\n    function performUpkeep(bytes calldata) external override {\\r\\n        // Gets upkeepNeeded bool from checkUpkeep() function\\r\\n        // Requires upkeepNeeded to be true.\\r\\n        // If s_state is SENT or ACCEPTED\\r\\n        //     s_state is set to CANCELLED\\r\\n        //     Refunds s_amountOfMoney to purchaserAddress.\\r\\n        //     Sets s_amountOfMoney to 0.\\r\\n        // If s_state is DISPUTE\\r\\n        //     s_state is set to DISPUTE_END\\r\\n        //     Sends (s_amountOfMoney - s_tokenWorthShipped) to i_purchaserAddress\\r\\n        //     Sets s_amountOfMoney to s_tokenWorthShipped.\\r\\n        //     Sends s_tokenWorthShipped token to i_vendorAddress.\\r\\n        //     Sets s_amountOfMoney to 0.\\r\\n    }\\r\\n}\",\"keccak256\":\"0xe493fa07bd4c1b8b75f98072811441a5920c4e86a99d74a8a03421387b65fea8\",\"license\":\"MIT\"},\"contracts/ProductOrderFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./ProductOrder.sol\\\";\\r\\n\\r\\ncontract ProductOrderFactory {\\r\\n    function createProductOrder(address vendorAddress, uint PONo, uint timeToAccept, uint timeToShip) public payable {\\r\\n        // Creates new ProductOrder contract with above parameters, as well as:\\r\\n        //     msg.sender as purchaserAddress\\r\\n        //     block.timestamp as acceptTimeStamp\\r\\n        // Also calls setPayment(), sending msg.value amount of token to it.\\r\\n    }\\r\\n}\",\"keccak256\":\"0xaa016b086f05617472ff8b63819518129fbdc38638776acffd09765d5466e13a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061017b806100206000396000f3fe60806040526004361061001e5760003560e01c806313673ffd14610023575b600080fd5b61003d600480360381019061003891906100de565b61003f565b005b50505050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006100758261004a565b9050919050565b6100858161006a565b811461009057600080fd5b50565b6000813590506100a28161007c565b92915050565b6000819050919050565b6100bb816100a8565b81146100c657600080fd5b50565b6000813590506100d8816100b2565b92915050565b600080600080608085870312156100f8576100f7610045565b5b600061010687828801610093565b9450506020610117878288016100c9565b9350506040610128878288016100c9565b9250506060610139878288016100c9565b9150509295919450925056fea2646970667358221220fba751ae24f4d2abbdd7533939f62bbfc02fdf0a8b10a8357a050ebc89db427264736f6c63430008080033",
  "deployedBytecode": "0x60806040526004361061001e5760003560e01c806313673ffd14610023575b600080fd5b61003d600480360381019061003891906100de565b61003f565b005b50505050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006100758261004a565b9050919050565b6100858161006a565b811461009057600080fd5b50565b6000813590506100a28161007c565b92915050565b6000819050919050565b6100bb816100a8565b81146100c657600080fd5b50565b6000813590506100d8816100b2565b92915050565b600080600080608085870312156100f8576100f7610045565b5b600061010687828801610093565b9450506020610117878288016100c9565b9350506040610128878288016100c9565b9250506060610139878288016100c9565b9150509295919450925056fea2646970667358221220fba751ae24f4d2abbdd7533939f62bbfc02fdf0a8b10a8357a050ebc89db427264736f6c63430008080033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}