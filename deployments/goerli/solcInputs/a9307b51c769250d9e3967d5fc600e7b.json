{
  "language": "Solidity",
  "sources": {
    "contracts/ProductOrderFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"./ProductOrder.sol\";\r\n\r\ncontract ProductOrderFactory {\r\n    function createProductOrder(address vendorAddress, uint PONo, uint timeToAccept, uint timeToShip) public payable returns (address) {\r\n        ProductOrder productOrder = new ProductOrder(msg.sender, vendorAddress, PONo, msg.value, timeToAccept, block.timestamp, timeToShip);\r\n        address POAddress = address(productOrder);\r\n        \r\n        payable(POAddress).transfer(msg.value);\r\n\r\n        // Sets up Upkeep for new contract.\r\n        //     https://docs.chain.link/docs/chainlink-automation/automation-economics/\r\n        //     https://automation.chain.link/?_ga=2.66826409.62596235.1667583413-1479646050.1660059585\r\n\r\n        return POAddress;\r\n    }\r\n}"
    },
    "contracts/ProductOrder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\r\n\r\nerror ProductOrder__NotFactory();\r\nerror ProductOrder__NotPurchaser();\r\nerror ProductOrder__NotVendor();\r\n\r\n\r\ncontract ProductOrder is KeeperCompatibleInterface {\r\n    // State of Order\r\n    enum POState {\r\n\t    SENT,\r\n\t    CANCELLED,\r\n\t    ACCEPTED,\r\n\t    DISPUTE,\r\n        END,\r\n        DISPUTE_END\r\n    }\r\n    POState private s_state;\r\n    \r\n    // All addresses\r\n    address private i_factoryAddress;\r\n    address private i_purchaserAddress;\r\n    address private i_vendorAddress;\r\n\r\n    // Amount of Money currently in contract\r\n    uint256 private s_amountOfMoney;\r\n\r\n    // Identifier to know what purchase order it is.\r\n    uint256 private i_PONo;\r\n\r\n    // Timing to accept and shipping\r\n    uint256 private i_timeToAccept;\r\n    uint256 private i_acceptTimeStamp;\r\n    uint256 private i_timeToShip;\r\n    uint256 private s_shippingTimeStamp;\r\n\r\n    // Dispute Variables\r\n    int256 private s_tokenWorthGot = -1;\r\n    uint256 private s_tokenWorthShipped;\r\n\r\n    // Events??\r\n\r\n    // Modifiers\r\n    modifier onlyFactory() {\r\n        // Continue if sender is the factory.\r\n        _;\r\n    }\r\n    modifier onlyPurchaser() {\r\n        // Continue if sender is the purchaser.\r\n        _;\r\n    }\r\n    modifier onlyVendor() {\r\n        // Continue if sender is the vendor.\r\n        _;\r\n    }\r\n\r\n    constructor(address purchaserAddress, address vendorAddress, uint256 PONo, uint256 amountOfMoney, uint256 timeToAccept, uint256 acceptTimeStamp, uint256 timeToShip) {\r\n        // Sets i_factoryAddress to msg.sender.\r\n        // Sets above parameters to their respective variables in the smart contract.\r\n        // Sets s_state to state SENT.\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    function cancelOrder() public payable onlyPurchaser {\r\n        // Requires s_state to be in SENT\r\n        // Refund s_amountOfMoney to purchaserAddress.\r\n        // Sets s_amountOfMoney to 0.\r\n        // Sets s_state to CANCELLED\r\n    }\r\n\r\n    function recievePurchaseOrder(bool orderAccepted, uint256 amountOfPOAccepted) public onlyVendor {\r\n        // Requires s_state to be SENT\r\n        // Requires amountOfPOAccepted to be less than s_amountOfMoney\r\n        // If orderAccepted is false\r\n        //     s_state is set to CANCELLED\r\n        //     Refunds s_amountOfMoney to purchaserAddress\r\n        //     Sets s_amountOfMoney to 0\r\n        // Else if orderAccepted is true\r\n        //     s_state is set to ACCEPTED.\r\n        //     Sets s_shippingTimeStamp to block.timestamp.\r\n        //     Refunds (s_amountOfMoney - amountOfPOAccepted) to purchaserAddress.\r\n        //     Sets s_amountOfMoney to amountOfPOAccepted\r\n    }\r\n\r\n    function setShipmentValue(uint256 shipmentValue) public payable onlyPurchaser {\r\n        // Requires s_state to be ACCEPTED\r\n        // Requires shipmentValue to be less than or equal to s_amountOfMoney and greater than 0.\r\n        // If shipmentValue is equal to s_amountOfMoney:\r\n        //     Send s_amountOfMoney to vendorAddress.\r\n        //     Sets s_amountOfMoney to 0.\r\n        //     s_state is set to END\r\n        // Else if shipment value isnâ€™t equal to s_amountOfMoney:\r\n        //     s_state is set to DISPUTE.\r\n        //     s_tokenWorthGot is set to shipmentValue\r\n    }\r\n\r\n    function setPurchaserDispute(uint256 tokenWorthGot) public onlyPurchaser {\r\n        // Sets s_tokenWorthGot to tokenWorthGot.\r\n    }\r\n\r\n    function setVendorDispute(uint256 tokenWorthShipped) public onlyVendor {\r\n        // Sets s_tokenWorthShipped to tokenWorthShipped.\r\n    }\r\n\r\n    function checkUpkeep(bytes memory) public override returns (bool upkeepNeeded, bytes memory) {\r\n        // If s_state is SENT\r\n        //     upkeepNeeded equals if (block.timestamp - i_acceptTimeStamp) is greater than i_timeToAccept.\r\n        // If s_state is ACCEPTED\r\n        //     upkeepNeeded both conditions (AND)\r\n        //         (block.timestamp - s_shippingTimeStamp) is greater than i_timeToShip\r\n        //         s_tokenWorthGot equals -1\r\n        // If s_state is DISPUTE\r\n        //     upkeepNeeded equals if s_tokenWorthGot and s_tokenWorthShipped are equal.\r\n    }\r\n\r\n    function performUpkeep(bytes calldata) external override {\r\n        // Gets upkeepNeeded bool from checkUpkeep() function\r\n        // Requires upkeepNeeded to be true.\r\n        // If s_state is SENT or ACCEPTED\r\n        //     s_state is set to CANCELLED\r\n        //     Refunds s_amountOfMoney to purchaserAddress.\r\n        //     Sets s_amountOfMoney to 0.\r\n        // If s_state is DISPUTE\r\n        //     s_state is set to DISPUTE_END\r\n        //     Sends (s_amountOfMoney - s_tokenWorthShipped) to i_purchaserAddress\r\n        //     Sets s_amountOfMoney to s_tokenWorthShipped.\r\n        //     Sends s_tokenWorthShipped token to i_vendorAddress.\r\n        //     Sets s_amountOfMoney to 0.\r\n    }\r\n\r\n    // Getter functions\r\n}"
    },
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * @notice This is a deprecated interface. Please use AutomationCompatibleInterface directly.\n */\npragma solidity ^0.8.0;\nimport {AutomationCompatibleInterface as KeeperCompatibleInterface} from \"./AutomationCompatibleInterface.sol\";\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}