{
  "language": "Solidity",
  "sources": {
    "contracts/ProductOrder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\r\n\r\nerror ProductOrder__NotPurchaser();\r\nerror ProductOrder__NotVendor();\r\n\r\n\r\ncontract ProductOrder is KeeperCompatibleInterface {\r\n    // State of Order\r\n    enum POState {\r\n\t    SENT,\r\n\t    CANCELLED,\r\n\t    ACCEPTED,\r\n\t    DISPUTE,\r\n        END,\r\n        DISPUTE_END\r\n    }\r\n    POState private s_state;\r\n    \r\n    // All addresses\r\n    address private immutable i_purchaserAddress;\r\n    address private immutable i_vendorAddress;\r\n\r\n    // Amount of Money currently in contract\r\n    uint256 private s_amountOfMoney;\r\n\r\n    // Identifier to know what purchase order it is.\r\n    uint256 private immutable i_PONo;\r\n\r\n    // Timing to accept and shipping\r\n    uint256 private immutable i_timeToAccept;\r\n    uint256 private immutable i_acceptTimeStamp;\r\n    uint256 private immutable i_timeToShip;\r\n    uint256 private s_shippingTimeStamp;\r\n\r\n    // Dispute Variables\r\n    int256 private s_tokenWorthGot = -1;\r\n    uint256 private s_tokenWorthShipped;\r\n\r\n    // Events??\r\n\r\n    // Modifiers\r\n    modifier onlyPurchaser() {\r\n        if (msg.sender != i_purchaserAddress) revert ProductOrder__NotPurchaser();\r\n        _;\r\n    }\r\n    modifier onlyVendor() {\r\n        if (msg.sender != i_vendorAddress) revert ProductOrder__NotVendor();\r\n        _;\r\n    }\r\n\r\n    constructor(address purchaserAddress, address vendorAddress, uint256 PONo, uint256 amountOfMoney, uint256 timeToAccept, uint256 acceptTimeStamp, uint256 timeToShip) {\r\n        i_purchaserAddress = purchaserAddress;\r\n        i_vendorAddress = vendorAddress;\r\n        i_PONo = PONo;\r\n        s_amountOfMoney = amountOfMoney;\r\n        i_timeToAccept = timeToAccept;\r\n        i_acceptTimeStamp = acceptTimeStamp;\r\n        i_timeToShip = timeToShip;\r\n        \r\n        s_state = POState.SENT;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    function cancelOrder() public payable onlyPurchaser {\r\n        require(s_state == POState.SENT);\r\n\r\n        payable(i_purchaserAddress).transfer(s_amountOfMoney);\r\n        s_amountOfMoney = 0;\r\n\r\n        s_state = POState.CANCELLED;\r\n    }\r\n\r\n    function recievePurchaseOrder(bool orderAccepted, uint256 amountOfPOAccepted) public onlyVendor {\r\n        require(s_state == POState.SENT);\r\n        require(amountOfPOAccepted <= s_amountOfMoney);\r\n\r\n        if (!orderAccepted) {\r\n            s_state = POState.CANCELLED;\r\n            payable(i_purchaserAddress).transfer(s_amountOfMoney);\r\n            s_amountOfMoney = 0;\r\n        }\r\n        else {\r\n            s_state = POState.ACCEPTED;\r\n            s_shippingTimeStamp = block.timestamp;\r\n            payable(i_purchaserAddress).transfer(s_amountOfMoney - amountOfPOAccepted);\r\n            s_amountOfMoney = amountOfPOAccepted;\r\n        }\r\n    }\r\n\r\n    function setShipmentValue(uint256 shipmentValue) public payable onlyPurchaser {\r\n        require(s_state == POState.ACCEPTED);\r\n        require(shipmentValue <= s_amountOfMoney);\r\n        require(shipmentValue >= 0);\r\n\r\n        if (shipmentValue == s_amountOfMoney) {\r\n            s_state = POState.END;\r\n            payable(i_vendorAddress).transfer(s_amountOfMoney);\r\n            s_amountOfMoney = 0;\r\n        }\r\n        else {\r\n            s_state == POState.DISPUTE;\r\n            s_tokenWorthGot = int256(shipmentValue);\r\n        }\r\n    }\r\n\r\n    function setPurchaserDispute(int256 tokenWorthGot) public onlyPurchaser {\r\n        s_tokenWorthGot = tokenWorthGot;\r\n    }\r\n\r\n    function setVendorDispute(uint256 tokenWorthShipped) public onlyVendor {\r\n        s_tokenWorthShipped = tokenWorthShipped;\r\n    }\r\n\r\n    function checkUpkeep(bytes memory) public override returns (bool upkeepNeeded, bytes memory) {\r\n        // If s_state is SENT\r\n        //     upkeepNeeded equals if (block.timestamp - i_acceptTimeStamp) is greater than i_timeToAccept.\r\n        // If s_state is ACCEPTED\r\n        //     upkeepNeeded both conditions (AND)\r\n        //         (block.timestamp - s_shippingTimeStamp) is greater than i_timeToShip\r\n        //         s_tokenWorthGot equals -1\r\n        // If s_state is DISPUTE\r\n        //     upkeepNeeded equals if s_tokenWorthGot and s_tokenWorthShipped are equal.\r\n    }\r\n\r\n    function performUpkeep(bytes calldata) external override {\r\n        // Gets upkeepNeeded bool from checkUpkeep() function\r\n        // Requires upkeepNeeded to be true.\r\n        // If s_state is SENT or ACCEPTED\r\n        //     s_state is set to CANCELLED\r\n        //     Refunds s_amountOfMoney to purchaserAddress.\r\n        //     Sets s_amountOfMoney to 0.\r\n        // If s_state is DISPUTE\r\n        //     s_state is set to DISPUTE_END\r\n        //     Sends (s_amountOfMoney - s_tokenWorthShipped) to i_purchaserAddress\r\n        //     Sets s_amountOfMoney to s_tokenWorthShipped.\r\n        //     Sends s_tokenWorthShipped token to i_vendorAddress.\r\n        //     Sets s_amountOfMoney to 0.\r\n    }\r\n\r\n    function getState() public view returns(POState) {\r\n        return s_state;\r\n    }\r\n\r\n    function getPurchaserAddress() public view returns(address) {\r\n        return i_purchaserAddress;\r\n    }\r\n\r\n    function getVendorAddress() public view returns(address) {\r\n        return i_vendorAddress;\r\n    }\r\n\r\n    function getAmountOfMoney() public view returns(uint256) {\r\n        return s_amountOfMoney;\r\n    }\r\n\r\n    function getPONo() public view returns(uint256) {\r\n        return i_PONo;\r\n    }\r\n\r\n    function getTimeToAccept() public view returns(uint256) {\r\n        return i_timeToAccept;\r\n    }\r\n\r\n    function getAcceptTimeStamp() public view returns(uint256) {\r\n        return i_acceptTimeStamp;\r\n    }\r\n\r\n    function getTimeToShip() public view returns(uint256) {\r\n        return i_timeToShip;\r\n    }\r\n\r\n    function getShippingTimeStamp() public view returns(uint256) {\r\n        return s_shippingTimeStamp;\r\n    }\r\n\r\n    function getTokenWorthGot() public view returns(int256) {\r\n        return s_tokenWorthGot;\r\n    }\r\n\r\n    function getTokenWorthShipped() public view returns(uint256) {\r\n        return s_tokenWorthShipped;\r\n    }\r\n}"
    },
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * @notice This is a deprecated interface. Please use AutomationCompatibleInterface directly.\n */\npragma solidity ^0.8.0;\nimport {AutomationCompatibleInterface as KeeperCompatibleInterface} from \"./AutomationCompatibleInterface.sol\";\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "contracts/ProductOrderFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"./ProductOrder.sol\";\r\n\r\ncontract ProductOrderFactory {\r\n    event POCreated(address PO, address purchaser, uint256 amountOfMoney, uint256 acceptTimeStamp);\r\n\r\n    function createProductOrder(address vendorAddress, uint256 PONo, uint256 timeToAccept, uint256 timeToShip) public payable {\r\n        address purchaser = msg.sender;\r\n        uint256 amountOfMoney = msg.value;\r\n        uint256 acceptTimeStamp = block.timestamp;\r\n\r\n        ProductOrder productOrder = new ProductOrder(purchaser, vendorAddress, PONo, amountOfMoney, timeToAccept, acceptTimeStamp, timeToShip);\r\n        address POAddress = address(productOrder);\r\n        \r\n        payable(POAddress).transfer(msg.value);\r\n\r\n        // Sets up Upkeep for new contract.\r\n        //     https://docs.chain.link/docs/chainlink-automation/automation-economics/\r\n        //     https://automation.chain.link/?_ga=2.66826409.62596235.1667583413-1479646050.1660059585\r\n\r\n        emit POCreated(POAddress, purchaser, amountOfMoney, acceptTimeStamp);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}