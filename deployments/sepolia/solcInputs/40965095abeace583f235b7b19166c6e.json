{
  "language": "Solidity",
  "sources": {
    "contracts/ProductOrder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\r\n\r\nerror ProductOrder__NotPurchaser();\r\nerror ProductOrder__NotVendor();\r\n\r\ncontract ProductOrder is KeeperCompatibleInterface {\r\n    // State of Order\r\n    enum POState {\r\n\t    SENT,\r\n\t    CANCELLED,  \r\n\t    ACCEPTED,\r\n\t    DISPUTE,\r\n        END,\r\n        DISPUTE_END\r\n    }\r\n    POState private s_state;\r\n    \r\n    // All addresses\r\n    address private immutable i_purchaserAddress;\r\n    address private immutable i_vendorAddress;\r\n\r\n    // Amount of Money currently in contract\r\n    uint256 private s_amountOfMoney;\r\n\r\n    // Identifier to know what purchase order it is.\r\n    uint256 private immutable i_PONo;\r\n\r\n    // Timing to accept and shipping\r\n    uint256 private immutable i_timeToAccept;\r\n    uint256 private immutable i_acceptTimeStamp;\r\n    uint256 private immutable i_timeToShip;\r\n    uint256 private s_shippingTimeStamp;\r\n\r\n    // Dispute Variables\r\n    int256 private s_tokenWorthGot = -1;\r\n    int256 private s_tokenWorthShipped = -2;\r\n\r\n    // Modifiers\r\n    modifier onlyPurchaser() {\r\n        if (msg.sender != i_purchaserAddress) revert ProductOrder__NotPurchaser();\r\n        _;\r\n    }\r\n    modifier onlyVendor() {\r\n        if (msg.sender != i_vendorAddress) revert ProductOrder__NotVendor();\r\n        _;\r\n    }\r\n\r\n    // Constructor to Create Smart Contract\r\n    constructor(address purchaserAddress, address vendorAddress, uint256 PONo, uint256 amountOfMoney, uint256 timeToAccept, uint256 acceptTimeStamp, uint256 timeToShip) {\r\n        i_purchaserAddress = purchaserAddress;\r\n        i_vendorAddress = vendorAddress;\r\n        i_PONo = PONo;\r\n        s_amountOfMoney = amountOfMoney;\r\n        i_timeToAccept = timeToAccept;\r\n        i_acceptTimeStamp = acceptTimeStamp;\r\n        i_timeToShip = timeToShip;\r\n        \r\n        s_state = POState.SENT;\r\n    }\r\n\r\n    // Receieve and Fallback Functions\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    // A function for the purchaser to cancel a sent order\r\n    function cancelOrder() public onlyPurchaser {\r\n        require(s_state == POState.SENT);\r\n\r\n        payable(i_purchaserAddress).transfer(s_amountOfMoney);\r\n        s_amountOfMoney = 0;\r\n\r\n        s_state = POState.CANCELLED;\r\n    }\r\n\r\n    // A function to let the vendor accept and receieve a purchase order\r\n    function recievePurchaseOrder(bool orderAccepted, uint256 amountOfPOAccepted) public onlyVendor {\r\n        require(s_state == POState.SENT);\r\n        require(amountOfPOAccepted <= s_amountOfMoney);\r\n\r\n        if (!orderAccepted) {\r\n            s_state = POState.CANCELLED;\r\n            payable(i_purchaserAddress).transfer(s_amountOfMoney);\r\n            s_amountOfMoney = 0;\r\n        }\r\n        else {\r\n            s_state = POState.ACCEPTED;\r\n            s_shippingTimeStamp = block.timestamp;\r\n            payable(i_purchaserAddress).transfer(s_amountOfMoney - amountOfPOAccepted);\r\n            s_amountOfMoney = amountOfPOAccepted;\r\n        }\r\n    }\r\n\r\n    // When the purchaser receieves the goods, they set the shipment value\r\n    function setShipmentValue(uint256 shipmentValue) public onlyPurchaser {\r\n        require(s_state == POState.ACCEPTED);\r\n        require(shipmentValue <= s_amountOfMoney);\r\n        require(shipmentValue >= 0);\r\n\r\n        if (shipmentValue == s_amountOfMoney) {\r\n            s_state = POState.END;\r\n            payable(i_vendorAddress).transfer(s_amountOfMoney);\r\n            s_amountOfMoney = 0;\r\n        }\r\n        else {\r\n            s_state = POState.DISPUTE;\r\n            s_tokenWorthGot = int256(shipmentValue);\r\n        }\r\n    }\r\n\r\n    // In a case of a dispute, this function lets the purchaser set their variable\r\n    function setPurchaserDispute(int256 tokenWorthGot) public onlyPurchaser {\r\n        require(s_state == POState.DISPUTE);\r\n        require(tokenWorthGot <= int256(s_amountOfMoney));\r\n        require(tokenWorthGot >= 0);\r\n        s_tokenWorthGot = tokenWorthGot;\r\n    }\r\n\r\n    // In a case of a dispute, this function lets the vendor set their variable\r\n    function setVendorDispute(int256 tokenWorthShipped) public onlyVendor {\r\n        require(s_state == POState.DISPUTE);\r\n        require(tokenWorthShipped <= int256(s_amountOfMoney));\r\n        require(tokenWorthShipped >= 0);\r\n        s_tokenWorthShipped = tokenWorthShipped;\r\n    }\r\n\r\n    // This function is the upkeep which checks the time the purchase order is sent, the time it takes to ship, and the dispute variables in their respective states\r\n    function checkUpkeep(bytes memory) public view override returns (bool upkeepNeeded, bytes memory) {\r\n        if (s_state == POState.SENT) {\r\n            upkeepNeeded = (block.timestamp - i_acceptTimeStamp) > i_timeToAccept;\r\n        } else if (s_state == POState.ACCEPTED) {\r\n            upkeepNeeded = ((block.timestamp - s_shippingTimeStamp) > i_timeToShip) && s_tokenWorthGot == -1;\r\n        } else if (s_state == POState.DISPUTE) {\r\n            upkeepNeeded = s_tokenWorthGot == s_tokenWorthShipped;\r\n        }\r\n    }\r\n\r\n    // This function performs upkeeps when conditions are met. When a sent or accepted purchase order runs out of time to accept or ship, this function refunds the purchaser.\r\n    // In a dispute, this function gives the deserved money to the purchaser and vendor.\r\n    function performUpkeep(bytes calldata) external override {\r\n        (bool upkeepNeeded, ) = checkUpkeep(\"\");\r\n        require(upkeepNeeded);\r\n\r\n        if (s_state == POState.SENT || s_state == POState.ACCEPTED) {\r\n            s_state = POState.CANCELLED;\r\n            payable(i_purchaserAddress).transfer(s_amountOfMoney);\r\n            s_amountOfMoney = 0;\r\n        } else if (s_state == POState.DISPUTE) {\r\n            s_state = POState.DISPUTE_END;\r\n            payable(i_purchaserAddress).transfer(s_amountOfMoney - uint256(s_tokenWorthShipped));\r\n            payable(i_vendorAddress).transfer(uint256(s_tokenWorthShipped));\r\n            s_amountOfMoney = 0;\r\n        }\r\n    }\r\n\r\n    // Getter functions for all the variables\r\n    function getState() public view returns(POState) {\r\n        return s_state;\r\n    }\r\n\r\n    function getPurchaserAddress() public view returns(address) {\r\n        return i_purchaserAddress;\r\n    }\r\n\r\n    function getVendorAddress() public view returns(address) {\r\n        return i_vendorAddress;\r\n    }\r\n\r\n    function getAmountOfMoney() public view returns(uint256) {\r\n        return s_amountOfMoney;\r\n    }\r\n\r\n    function getPONo() public view returns(uint256) {\r\n        return i_PONo;\r\n    }\r\n\r\n    function getTimeToAccept() public view returns(uint256) {\r\n        return i_timeToAccept;\r\n    }\r\n\r\n    function getAcceptTimeStamp() public view returns(uint256) {\r\n        return i_acceptTimeStamp;\r\n    }\r\n\r\n    function getTimeToShip() public view returns(uint256) {\r\n        return i_timeToShip;\r\n    }\r\n\r\n    function getShippingTimeStamp() public view returns(uint256) {\r\n        return s_shippingTimeStamp;\r\n    }\r\n\r\n    function getTokenWorthGot() public view returns(int256) {\r\n        return s_tokenWorthGot;\r\n    }\r\n\r\n    function getTokenWorthShipped() public view returns(int256) {\r\n        return s_tokenWorthShipped;\r\n    }\r\n}"
    },
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/**\n * @notice This is a deprecated interface. Please use AutomationCompatibleInterface directly.\n */\npragma solidity ^0.8.0;\nimport {AutomationCompatibleInterface as KeeperCompatibleInterface} from \"./AutomationCompatibleInterface.sol\";\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "contracts/ProductOrderFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"./ProductOrder.sol\";\r\n\r\ncontract ProductOrderFactory {\r\n    // Event that is emit when a purchase order is created\r\n    event POCreated(address PO, address purchaser, uint256 amountOfMoney, uint256 acceptTimeStamp);\r\n\r\n    // Function for a purchase to create a product order\r\n    function createProductOrder(address vendorAddress, uint256 PONo, uint256 timeToAccept, uint256 timeToShip) public payable {\r\n        address purchaser = msg.sender;\r\n        uint256 amountOfMoney = msg.value;\r\n        uint256 acceptTimeStamp = block.timestamp;\r\n\r\n        ProductOrder productOrder = new ProductOrder(purchaser, vendorAddress, PONo, amountOfMoney, timeToAccept, acceptTimeStamp, timeToShip);\r\n        address POAddress = address(productOrder);\r\n        \r\n        payable(POAddress).transfer(msg.value);\r\n\r\n        emit POCreated(POAddress, purchaser, amountOfMoney, acceptTimeStamp);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}